/**
 * Not 100% accurate but should give a decent enough
 * estimation of the required tokens.
 */
export const countTokens = (str: string) => {
	let tokenCount = 0;
	let inWord = false;

	for (let i = 0; i < str.length; i++) {
		if (str[i]?.trim() === '') {
			inWord = false;
		} else if ([' ', '\t', '\n', '\r'].includes(str[i]!)) {
			inWord = false;
			tokenCount++; // for spaces and other whitespace characters
		} else if (!inWord) {
			inWord = true;
			tokenCount++;
		}
	}

	return tokenCount;
};

export interface TestCase {
	title: string;
	steps: Array<{
	  component: string;
	  data?: string;
	  result?: string;
	}>;
  }
  
  export const extractTestCasesFromMarkdown = (markdown: string): TestCase[] => {
	const testCases: TestCase[] = [];
	const lines = markdown.split('\n');
	let testCase: TestCase | null = null;
	let action: { component: string; data?: string; result?: string } | null = null;
  
	for (const line of lines) {
	  if (line.startsWith('**Test Case')) {
		if (testCase) {
		  if (action) {
			testCase.steps.push(action);
		  }
		  testCases.push(testCase);
		}
		testCase = {
		  title: line.replace('**Test Case', '').trim(),
		  steps: [],
		};
	  } else if (line.trim() && !line.startsWith('|')) {
		if (action) {
		  testCase?.steps.push(action);
		}
		action = {
		  component: line,
		  data: undefined,
		  result: undefined,
		};
	  } else if (action && line.trim() && line.startsWith('|')) {
		const parts = line.split('|');
		if (parts.length === 4) {
		  action.component = parts[1]!.trim();
		  action.data = parts[2]!.trim();
		  action.result = parts[3]!.trim();
		}
	  }
	}
  
	if (testCase) {
	  if (action) {
		testCase.steps.push(action);
	  }
	  testCases.push(testCase);
	}
  
	return testCases;
  };
  

export const generateCSV = (markdown: string) => {
	const testCases = extractTestCasesFromMarkdown(markdown);
	let csv = 'TCID;Test Summary;Test Priority;Component;Component;Action;Data;Result\n';

	let tcid = 1;
	for (const testCase of testCases) {
		const testSummary = testCase.title;
		const testPriority = ' '; // Leaving it empty

		for (const step of testCase.steps) {
			if (step['component'] && step['data'] && step['result']) {
				csv += `${tcid};${testSummary};${testPriority};;${step['component']};;${step['data']};${step['result']}\n`;
				tcid++;
			}
		}
	}

	return csv;
};

export const parseScoringResponse = (text: string) => {
	const lines = text.trim().split('\n');
	const variables: any = {};

	for (const line of lines) {
		const [key, value] = line.split(':').map((item) => item.trim());
		// Clean up the key by removing asterisks and trimming spaces
		const cleanKey = key?.replace(/\*/g, '').trim();

		if (cleanKey == '3C') variables['3c'] = value === 'OUI';
		if (cleanKey == 'INVEST') variables['invest'] = value === 'OUI';
		if (cleanKey == 'ID') variables['id'] = value === 'OUI';
		if (cleanKey == 'Critères d’acceptation') variables['acceptationCriteria'] = value === 'OUI';
		if (cleanKey == 'Description de l’utilisateur type') variables['persona'] = value === 'OUI';
		if (cleanKey == 'Section dédiée à la contextualisation') variables['context'] = value === 'OUI';
		if (cleanKey == 'Section d’implémentation technique') variables['tech'] = value === 'OUI';
		if (cleanKey == 'Section graphique montrant le rendu visuel')
			variables['design'] = value === 'OUI';
		if (cleanKey == 'Section de tracking montrant le comportement de l’utilisateur')
			variables['tracking'] = value === 'OUI';
		if (cleanKey == 'Priorité de développement') variables['priority'] = value === 'OUI';
		if (cleanKey == 'Fonctionnalité') variables['behavior'] = value === 'OUI';
		if (cleanKey == 'Performance') variables['performance'] = value === 'OUI';
		if (cleanKey == 'Sécurité') variables['security'] = value === 'OUI';
		if (cleanKey == 'Interopérabilité') variables['interoperability'] = value === 'OUI';
		if (cleanKey == 'Maintenabilité') variables['maintenability'] = value === 'OUI';
		if (cleanKey == 'Compatibilité') variables['compatibility'] = value === 'OUI';
		if (cleanKey == 'Fiabilité') variables['fiability'] = value === 'OUI';
	}

	return variables;
};

export const computeScore = (criteria: any) => {
	let score = criteria['3c'] ? 1 : 0;
	score += criteria.invest ? 2 : 0;
	score += criteria.id ? 3 : 0;
	score += criteria.acceptationCriteria ? 3 : 0;
	score += criteria.persona ? 1 : 0;
	score += criteria.tech ? 2 : 0;
	score += criteria.design ? 2 : 0;
	score += criteria.tracking ? 1 : 0;
	score += criteria.priority ? 3 : 0;
	score += criteria.behavior ? 3 : 0;
	score += criteria.performance ? 2 : 0;
	score += criteria.security ? 1 : 0;
	score += criteria.interoperability ? 1 : 0;
	score += criteria.maintenability ? 1 : 0;
	score += criteria.compatibility ? 1 : 0;
	score += criteria.fiability ? 1 : 0;

	return Math.ceil((score / 28) * 100);
};
