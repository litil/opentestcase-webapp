export const buildScoringPrompt = (issueType: string, description: string) => {
	const oldPrompt = `Voici une ${issueType}:
      ${description}
      En tant que Product Manager expert, évalue la complétude de la ${issueType} en attribuant une note en pourcentage (%) de façon sévère. Voici les étapes à suivre pour cette évaluation :
      Commence par attribuer une note de complétude initiale en pourcentage (%) à la ${issueType} telle qu'elle est présentée. Cette note qui doit être sévère reflète ta première impression de la complétude de la ${issueType}.
      Réévalue ta note initiale si la ${issueType} remplit tous les critères de la méthode des 3C et de la méthode INVEST. Fais baisser la note si ces critères sont incomplets ou non remplis.
      Réévalue ta note une seconde fois en prenant en compte la présence des éléments suivants :
      - La présence d'un identifiant unique clairement défini pour le document.
      - L'existence d'une section dédiée à la contextualisation de la ${issueType}, qui explique le contexte, le besoin auquel elle répond et les objectifs de manière claire et compréhensible.
      - L'inclusion d'une section spécifique aux critères d'acceptation, qui doivent être concrets, complets, exacts et précis.
      - La présence d'une section technique expliquant comment le ${issueType} sera implémentée.
      - L'utilisateur type est clairement identifié
      Ensuite, affine ta note en prenant également en compte la présence d'informations liées aux critères de qualité suivants :
      - Complétude fonctionnelle
      - Performance
      - Sécurité
      - interopérabilité
      - Maintenabilité
      - Compatibilité
      - Fiabilité
      Ensuite, en prenant en compte les critères précédents, compléte ta notation avec tous les critères suplémentaires que tu jugeras pertinents pour garantir la meilleure qualité et fiabilité de la note.
      Enfin, re-génère 3 fois le prompt et fais la moyenne des scores en notant toujours très sévèrement.
      L'objectif de cette évaluation est de déterminer de manière sévère mais objective la complétude de la user story en tenant compte de plusieurs aspects, y compris les éléments essentiels, les critères d'acceptation, et les critères de qualité. La note finale doit refléter de manière précise le niveau de complétude de la user story. Sois aussi précis que possible dans votre évaluation.
      `;

	const newPromptOct30 = `Voici une ${issueType}:
      ${description}
      Rôle = Expert métier et product manager
  
      Définis explicitement par OUI ou par NON si cette ${issueType} possède des informations concrètes, explicites et claires concernant chacun des concepts suivants : 
      3C : OUI ou NON
      INVEST : OUI ou NON
      La présence d'un identifiant unique clairement défini pour le document
      L'inclusion d'une section spécifique aux critères d'acceptation, qui doivent être concrets, complets, exacts et précis : OUI ou NON
      L'utilisateur type est-il clairement identifié : OUI ou NON
      L'existence d'une section dédiée à la contextualisation de la ${issueType}, qui explique le contexte, le besoin auquel elle répond et les objectifs de manière claire et compréhensible : OUI ou NON
      La présence d'une section technique expliquant comment la ${issueType} sera implémentée : OUI ou NON
      La présence d'une section graphique montrant le rendu visuel de la ${issueType} : OUI ou NON
      La présence d'une section de tracking montrant le comportement de l'utilisateur : OUI ou NON
      La présence d'une priorité de développement : OUI ou NON
      Complétude fonctionnelle : OUI ou NON
      Performance : OUI ou NON
      Sécurité : OUI ou NON
      Interopérabilité : OUI ou NON
      Maintenabilité : OUI ou NON
      Compatibilité : OUI ou NON
      Fiabilité : OUI ou NON
  
      L'objectif de cette évaluation est de déterminer, de manière sévère mais objective, la complétude de la user story en tenant compte de plusieurs aspects. Ne réponds que par OUI ou par NON sans donner aucun détail supplémentaire
  
      Formate l'output comme dans l'exemple suivant :
      **3C** : OUI ou NON
      **INVEST** : OUI ou NON
      **ID** : OUI ou NON
      **Critères d'acceptation** : OUI ou NON
      **Description de l'utilisateur type** : OUI ou NON
      **Section dédiée à la contextualisation** : OUI ou NON
      **Section d'implémentation technique** : OUI ou NON
      **Section graphique montrant le rendu visuel** : OUI ou NON
      **Section de tracking montrant le comportement de l'utilisateur** : OUI ou NON
      **Priorité de développement** : OUI ou NON
      **Fonctionnalité** : OUI ou NON
      **Performance** : OUI ou NON
      **Sécurité** : OUI ou NON
      **interopérabilité** : OUI ou NON
      **Maintenabilité** : OUI ou NON
      **Compatibilité** : OUI ou NON
      **Fiabilité** : OUI ou NON`;

      return [
            {
              role: "user",
              content: newPromptOct30,
            },
          ]
};

export const buildReviewingPrompt = (issueType: string, description: string, language: string) => {
	const prompt = `Voici une ${issueType}:
      ${description}
      Rôle = Expert métier et product manager
  
      Prompt = Effectue la relecture fonctionnelle et technique de cette ${issueType}. L'objectif de cette relecture est de compléter le document, de livrer un rapport de revue et de créer des cas de test.
      Identifie clairement l'identifiant unique du document et s'il n'y en a pas note une alerte
      S'il n'y a pas de section “critères d'acceptation” dans le document note une alerte et propose des critères d'acceptations explicites qui définissent clairement les normes de réussite du produit
      Ensuite, selon toi, quelles informations sont manquantes, incomplètes ou inexactes ? Donne des exemples concrêts.
      Ensuite, affine ta relecture en la complétant avec les critères de qualité suivants, pour chacun de ces critères, fournis de nombreux détails spécifiques et des exemples concrets pour évaluer le document, identifie les lacunes et propose des améliorations : 
      Performance
      Sécurité
      interopérabilité
      Maintenabilité
      Compatibilité
      Fiabilité
      Enfin, en prenant en compte les remarques générées au cours de cette relecture, compléte la liste avec toutes les informations supplémentaires pertinentes et nouvelles que tu juges nécessaires pour garantir la qualité et la complétude du document. Ce rapport de revue doit être exhaustif et précis pour orienter les prochaines étapes du projet.
  
      Formate l'output comme dans l'exemple suivant :
      **ID**
      **Critères d'acceptation**
      **Performance**
      **Sécurité**
      **interopérabilité**
      **Maintenabilité**
      **Compatibilité**
      **Fiabilité**
      **Informations manquantes, incomplètes ou inexactes**
      **Informations supplémentaires pertinentes et nouvelles**
  
      Langue = ${language}
      `;

      return [
            {
              role: "user",
              content: prompt,
            },
          ]
};

export const buildTestCaseGeneratorPrompt = (issueType: string, description: string, language: string) => {
      const prompt = `Voici une ${issueType}:
        ${description}
        Rôle = Expert QA
  
      Prompt = Génère un maximum de cas de test nécessaires pour couvrir à 100% cette ${issueType} incluant les cas de test positifs, les cas de test négatifs et les edge cases.
      Pour chaque cas de test, rédige les prérequis de test nécessaire.
      Pour chaque cas de test, rédige toutes les étapes de test avec le maximum de détails sous la forme d'un tableau en markdown avec 1 colonne contenant toutes les actions précisément décrites et exhaustives et 1 colonne contenant les résultats attendus précisément décrits et exhaustifs. 
      Donne un maximum d'actions par cas de test avec toutes les précisions de façon compréhensible et ordonnée.        
      Enfin, en tenant compte des cas de test que tu as générés, complète la liste avec des cas de test supplémentaires et nouveaux.
  
      Formate l'output comme dans l'exemple suivant :
      **Titre du cas de test**
      _Prérequis de test :_
      1.Prérequis 1
      2.Prérequis 2
  
      |#|Actions|Résultats attendus|
  
      Langue = ${language}
      \`\`\``;

      return [
            {
              role: "user",
              content: prompt,
            },
          ]
};

export const buildTestCaseGeneratorGerkinPrompt = (issueType: string, description: string, language: string) => {
	const oldPrompt = `Voici une ${issueType}:
      ${description}
      En tant qu'expert QA, liste de façon exhaustive, le maximum de cas de test nécessaires pour garantir une couverture de 100% de cette ${issueType} incluant les cas de test positifs, les cas de test négatifs et les cas de test edge (limites). Voici les directives spécifiques :
  Chaque cas de test doit être rédigé en langage Gherkin, qui est un langage de spécification comportementale facile à comprendre. Chaque scénario de test doit être clair, précis et suivi du mot-clé "Scénario".
  Pour chaque cas de test, identifie clairement les actions à effectuer, les étapes à suivre et les entrées requises. Utilisez des mots clés comme "Étant donné" pour décrire le contexte initial, "Quand" pour décrire l'action à effectuer, et "Alors" pour décrire le résultat attendu.
  Enfin, après avoir généré la liste initiale de cas de test, assure-toi de la compléter avec des cas de test supplémentaires et nouveaux, en fonction des spécifications du document et des considérations de qualité. Ces cas de test supplémentaires doivent également être rédigés en langage Gherkin et suivre les mêmes directives que précédemment.
  L'objectif est de fournir une liste complète de scénarios de test qui couvrent tous les aspects de la user story, garantissant ainsi la qualité et la conformité aux spécifications.
  Rédige en ${language} et sois aussi précis que possible dans la rédaction de chaque cas de test.
      `;

      const prompt = `Voici une ${issueType}:
      ${description}Rôle = Expert QA
  
      Prompt = Liste de façon exhaustive, le maximum de cas de test nécessaires pour garantir une couverture de 100% de cette ${issueType} incluant les cas de test positifs, les cas de test négatifs et les cas de test edge (limites). Voici les directives spécifiques :
      Chaque cas de test doit être rédigé en langage Gherkin, qui est un langage de spécification comportementale facile à comprendre. Chaque scénario de test doit être clair, précis et suivi du mot-clé "Scénario".
      Pour chaque cas de test, identifie clairement les actions à effectuer, les étapes à suivre et les entrées requises. Utilisez des mots clés comme "Étant donné" pour décrire le contexte initial, "Quand" pour décrire l'action à effectuer, et "Alors" pour décrire le résultat attendu.
      Enfin, après avoir généré la liste initiale de cas de test, assure-toi de la compléter avec des cas de test supplémentaires et nouveaux, en fonction des spécifications du document et des considérations de qualité. Ces cas de test supplémentaires doivent également être rédigés en langage Gherkin et suivre les mêmes directives que précédemment.
      L'objectif est de fournir une liste complète de scénarios de test qui couvrent tous les aspects de la user story, garantissant ainsi la qualité et la conformité aux spécifications.
      
      Formate l'output comme dans l'exemple suivant :
      **Scénario 1 : titre du cas de test**
      \`\`\`cas de test\`\`\`
      **Scénario 2 : titre du cas de test**
      \`\`\`cas de test\`\`\`
      
      Langue = ${language}`;

      return [
            {
              role: "user",
              content: prompt,
            },
          ]
};

export const buildAutomatedTestsPrompt = (language: string, library: string, generatedTestCases: any) => {
	const progLanguage = library == 'cypress' ? 'javascript' : 'python';
	const oldPrompt = `En tant qu'expert en assurance qualité (QA) spécialisé dans l'automatisation, rédige des scripts d'automatisation en langage ${progLanguage}, en utilisant ${library}, pour chacun des cas de test précédemment définis. Chaque cas de test doit être couvert par un script de test automatisé. Voici les directives spécifiques :
  Pour chaque cas de test, rédige un script d'automatisation en langage ${progLanguage}, en utilisant ${library}, qui effectue les actions nécessaires pour exécuter le test de manière automatisée. Assurez-vous que chaque script est clair, bien documenté et suit les meilleures pratiques en matière de codage.
  Après avoir généré les scripts de test automatisés, assure-toi de les compléter avec toutes les informations supplémentaires importantes. Cela peut inclure des commentaires décrivant la logique du test, les données d'entrée requises, les assertions pour vérifier les résultats, etc. Veille à ce que chaque script soit accompagné de documentation précise pour faciliter la compréhension et la maintenance ultérieure.
  Fourni également une liste d'éléments à prendre en compte et à surveiller en ce qui concerne les scripts de test automatisés que tu as proposés. Cela pourrait inclure des considérations de stabilité, de gestion des dépendances, de gestion des données de test, et d'autres aspects pertinents de l'automatisation des tests.
  L'objectif est de créer des scripts d'automatisation robustes et complets qui permettent d'exécuter tous les cas de test de manière automatisée, tout en assurant la qualité et la fiabilité des tests automatisés. Soyez précis dans la rédaction de vos scripts et de votre documentation, et veillez à ce que les scripts soient maintenables à long terme.
  Rédige en ${language}.`;

	const prompt = `En tant qu'expert en assurance qualité (QA) spécialisé dans l'automatisation, rédige des scripts d'automatisation en langage ${progLanguage} pour chacun des cas de test précédemment définis. Chaque cas de test doit être couvert par un script de test automatisé. Voici les directives spécifiques :
    Pour chaque cas de test, rédige un script d'automatisation en langage ${progLanguage} qui effectue les actions nécessaires pour exécuter le test de manière automatisée. Assurez-vous que chaque script est clair, bien documenté et suit les meilleures pratiques en matière de codage.
    Après avoir généré les scripts de test automatisés, assure-toi de les compléter avec toutes les informations supplémentaires importantes. Cela peut inclure des commentaires décrivant la logique du test, les données d'entrée requises, les assertions pour vérifier les résultats, etc. Veille à ce que chaque script soit accompagné de documentation précise pour faciliter la compréhension et la maintenance ultérieure.
    Fourni également une liste d'éléments à prendre en compte et à surveiller en ce qui concerne les scripts de test automatisés que tu as proposés. Cela pourrait inclure des considérations de stabilité, de gestion des dépendances, de gestion des données de test, et d'autres aspects pertinents de l'automatisation des tests.
    L'objectif est de créer des scripts d'automatisation robustes et complets qui permettent d'exécuter tous les cas de test de manière automatisée, tout en assurant la qualité et la fiabilité des tests automatisés. Soyez précis dans la rédaction de vos scripts et de votre documentation, et veillez à ce que les scripts soient maintenables à long terme.
    `;
      
    return [
      {role: "user", content: `Here are the test cases you generated before. /n${generatedTestCases}.`},
      {
        role: "user",
        content: prompt,
      },
    ]
};
